# DERs Safe Aggregation API 接口说明文档

## 概述

DERs Safe Aggregation API 是一个分布式能源资源（DERs）安全聚合优化计算服务，提供 RESTful API 接口，用于计算虚拟电厂（VPP）在满足电网安全约束条件下的最大聚合能力。

### 服务信息

- **服务地址**: `http://localhost:5123`
- **API 前缀**: `/xxaqy-api`
- **支持协议**: HTTP/HTTPS
- **数据格式**: JSON

---

## 接口列表

### 1. 健康检查

**接口路径**: `GET /xxaqy-api/health`

**功能说明**: 

检查 API 服务是否正常运行，用于服务监控和健康状态检查。

**使用场景**:

- 服务启动验证
- 负载均衡健康检查
- 监控系统状态探测

**请求参数**: 

无

**响应示例**:

```json
{
  "status": "healthy",
  "message": "DERs Safe Aggregation API is running"
}
```

**响应字段说明**:

| 字段 | 类型 | 说明 |
|------|------|------|
| status | string | 服务状态，固定为 "healthy" |
| message | string | 状态消息 |

---

### 2. 构建约束矩阵

**接口路径**: 

`POST /xxaqy-api/matrices/build`

**功能说明**: 

构建电力网络的约束矩阵，包括电压约束矩阵、电流约束矩阵以及相关的灵敏度矩阵。这些矩阵用于后续的聚合优化计算，定义了电网运行的安全边界。

**核心功能**:

1. 构建电压运行安全域参数（`A_V`, `b_V`）：定义各节点电压的上下限约束
2. 构建电流运行安全域参数（`A_I`, `b_I`）：定义各支路电流的安全约束
3. 计算等效电阻和电抗矩阵（`R_hat`, `X_hat`, `R_I`, `X_I`）：用于描述电网的电气特性
4. 计算负荷相关的约束系数（`C_MI_load_neg`, `C_MI_load_pos`, `C_mV_load`, `C_MV_load`）

**使用场景**:

- 首次使用前预构建约束矩阵
- 网络拓扑变化后重建约束矩阵
- 调试和验证约束矩阵的正确性

**请求参数**:

```json
{
  "verbose": false,
  "vpp_nodes": [10, 15, 18, 20, 25]
}
```

**参数说明**:

| 字段 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| verbose | boolean | 否 | false | 是否输出详细构建信息 |
| vpp_nodes | array[integer] | 否 | [10, 15, 18, 20, 25] | VPP节点列表（用于文档记录，不影响实际计算） |

**响应示例**:

```json
{
  "success": true,
  "data": {
    "A_V": [[...], [...]],
    "b_V": [[...], [...]],
    "A_I": [[...], [...]],
    "b_I": [[...], [...]],
    "R_hat": [[...], [...]],
    "X_hat": [[...], [...]],
    "R_I": [[...], [...]],
    "X_I": [[...], [...]],
    "Pd": [...],
    "Qd": [...],
    "C_MI_load_neg": [...],
    "C_MI_load_pos": [...],
    "C_mV_load": [...],
    "C_MV_load": [...],
    "shapes": {
      "A_V": [64, 10],
      "b_V": [64, 1],
      ...
    }
  },
  "vpp_nodes": [10, 15, 18, 20, 25]
}
```

**响应字段说明**:

| 字段 | 类型 | 说明 |
|------|------|------|
| success | boolean | 是否成功 |
| data.A_V | array[array[number]] | 电压约束矩阵，形状为 (约束数量, 变量数量) |
| data.b_V | array[array[number]] | 电压约束向量 |
| data.A_I | array[array[number]] | 电流约束矩阵 |
| data.b_I | array[array[number]] | 电流约束向量 |
| data.R_hat | array[array[number]] | 等效电阻矩阵（电压灵敏度） |
| data.X_hat | array[array[number]] | 等效电抗矩阵（电压灵敏度） |
| data.R_I | array[array[number]] | 电流约束等效电阻矩阵 |
| data.X_I | array[array[number]] | 电流约束等效电抗矩阵 |
| data.Pd | array[number] | 有功负荷向量 |
| data.Qd | array[number] | 无功负荷向量 |
| data.C_MI_load_neg | array[number] | 负荷负向电流约束系数 |
| data.C_MI_load_pos | array[number] | 负荷正向电流约束系数 |
| data.C_mV_load | array[number] | 负荷最小电压约束系数 |
| data.C_MV_load | array[number] | 负荷最大电压约束系数 |
| data.shapes | object | 各矩阵的形状信息 |
| vpp_nodes | array[integer] | VPP节点列表 |

**注意事项**:

- 该接口的计算基于固定的网络拓扑（IEEE 33节点系统）
- 约束矩阵的构建是聚合计算的基础，通常在系统初始化时执行
- 矩阵构建过程会考虑负荷的基态影响

---

### 3. 初始化聚合器

**接口路径**: 

`POST /xxaqy-api/aggregator/init`

**功能说明**: 

初始化 VPP 聚合器实例，创建并缓存聚合器对象。聚合器内部会调用 `build_matrices` 函数构建约束矩阵，为后续的聚合优化计算做准备。

**核心功能**:

1. 根据指定的 VPP 节点列表创建聚合器实例
2. 内部自动加载并切片网络约束矩阵（提取 VPP 节点相关的约束）
3. 将聚合器实例缓存到内存中，提高后续计算的效率

**使用场景**:

- 在批量计算前预初始化聚合器，提高计算效率
- 切换不同的 VPP 节点配置
- 系统初始化时提前准备聚合器实例

**请求参数**:

```json
{
  "vpp_nodes": [10, 15, 18, 20, 25]
}
```

**参数说明**:

| 字段 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| vpp_nodes | array[integer] | 是 | - | VPP 节点编号列表，至少包含一个节点 |

**响应示例**:

```json
{
  "success": true,
  "message": "Aggregator initialized successfully",
  "vpp_nodes": [10, 15, 18, 20, 25],
  "cache_key": "10,15,18,20,25"
}
```

**响应字段说明**:

| 字段 | 类型 | 说明 |
|------|------|------|
| success | boolean | 是否成功 |
| message | string | 响应消息 |
| vpp_nodes | array[integer] | 已初始化的 VPP 节点列表 |
| cache_key | string | 缓存键，用于后续复用该聚合器实例 |

**错误响应**:

```json
{
  "success": false,
  "error": "vpp_nodes must be a non-empty list"
}
```

**注意事项**:

- 相同节点列表的聚合器会被缓存，后续计算可复用
- 节点编号对应电网中的实际节点编号（如 IEEE 33 节点系统）
- 初始化失败通常是因为网络矩阵构建失败

---

### 4. 执行聚合优化计算（多时间步）

**接口路径**: 

`POST /xxaqy-api/aggregator/solve`

**功能说明**: 

执行多时间步的聚合优化计算，计算每个时间步 VPP 在满足电网安全约束条件下的最大注入功率和最大吸收功率。这是系统的核心接口，通过线性规划优化方法求解。

**核心功能**:

1. **最大注入功率计算**：在满足电压和电流约束的前提下，计算 VPP 能够向电网注入的最大功率
2. **最大吸收功率计算**：在满足安全约束的前提下，计算 VPP 能够从电网吸收的最大功率
3. **多时间步滚动优化**：对每个时间步独立进行优化计算，支持 24 小时或更长时间段的聚合能力分析

**算法原理**:

- 使用线性规划（Linear Programming）求解
- 优化目标：最大化净注入功率（或最小化净负荷）
- 约束条件：
  - 电压约束：各节点电压在 [0.95, 1.05] pu 范围内
  - 电流约束：各支路电流不超过热容量限制
  - 物理约束：各 DER 的功率输出不超过其物理上限

**使用场景**:

- 24 小时聚合能力曲线计算
- 日前/日内聚合调度方案生成
- 聚合能力评估和资源优化配置

**请求参数**:

```json
{
  "vpp_nodes": [10, 15, 18, 20, 25],
  "p_inj_max_profile": [
    [40000, 10000, 40000, 4000, 4000],
    [38000, 9500, 38000, 3800, 3800],
    ...
  ],
  "p_abs_max_profile": [
    [1000, 1000, 1000, 1000, 1000],
    [1100, 1100, 1100, 1100, 1100],
    ...
  ],
  "q_ratio": 0.5,
  "use_cache": true
}
```

**参数说明**:

| 字段 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| vpp_nodes | array[integer] | 是 | - | VPP 节点编号列表 |
| p_inj_max_profile | array[array[number]] | 是 | - | 多时间步最大注入功率矩阵，形状为 (时间步数, 节点数)，单位：kW |
| p_abs_max_profile | array[array[number]] | 是 | - | 多时间步最大吸收功率矩阵，形状为 (时间步数, 节点数)，单位：kW（正值） |
| q_ratio | number | 否 | 0.5 | 无功功率比例，用于自动计算 Q 边界，范围 [0, 1] |
| use_cache | boolean | 否 | true | 是否使用缓存的聚合器实例 |

**参数约束**:

- `p_inj_max_profile` 和 `p_abs_max_profile` 必须为 2D 数组
- 两个矩阵的形状必须相同
- 矩阵的列数必须等于 `vpp_nodes` 的长度
- 所有功率值为非负数

**响应示例**:

```json
{
  "success": true,
  "data": {
    "net_inj_max": [85000.5, 82000.3, ...],
    "net_abs_max": [4500.2, 4800.1, ...],
    "phy_inj_sum": [90000.0, 87000.0, ...],
    "phy_abs_sum": [5000.0, 5500.0, ...]
  },
  "metadata": {
    "vpp_nodes": [10, 15, 18, 20, 25],
    "num_time_steps": 24,
    "num_vpp_nodes": 5,
    "q_ratio": 0.5
  }
}
```

**响应字段说明**:

| 字段 | 类型 | 说明 |
|------|------|------|
| success | boolean | 是否成功 |
| data.net_inj_max | array[number] | 各时间步的最大安全注入功率（kW），考虑了电网约束 |
| data.net_abs_max | array[number] | 各时间步的最大安全吸收功率（kW），考虑了电网约束 |
| data.phy_inj_sum | array[number] | 各时间步的物理注入功率总和（kW），不考虑电网约束 |
| data.phy_abs_sum | array[number] | 各时间步的物理吸收功率总和（kW），不考虑电网约束 |
| metadata.vpp_nodes | array[integer] | VPP 节点列表 |
| metadata.num_time_steps | integer | 时间步数量 |
| metadata.num_vpp_nodes | integer | VPP 节点数量 |
| metadata.q_ratio | number | 使用的无功功率比例 |

**结果解读**:

- `net_inj_max` vs `phy_inj_sum`：网络安全约束对注入功率的限制
- `net_abs_max` vs `phy_abs_sum`：网络安全约束对吸收功率的限制
- 通常 `net_*` ≤ `phy_*`，差值反映了电网约束的影响

**错误响应**:

```json
{
  "success": false,
  "error": "p_inj_max_profile and p_abs_max_profile are required"
}
```

**注意事项**:

- 计算时间与时间步数和节点数相关，建议合理设置超时时间
- 使用缓存可以提高计算效率，特别是在批量计算场景
- 如果优化失败，相应时间步的结果会返回 NaN

---

### 5. 计算单个时间步的聚合能力

**接口路径**: 

`POST /xxaqy-api/aggregator/solve/single`

**功能说明**: 

计算单个时间步的聚合能力，功能与多时间步接口相同，但只处理当前时刻的数据。适合实时计算和单点查询场景。

**核心功能**:

与多时间步接口相同，但只计算单个时间步的结果，返回标量值而非数组。

**使用场景**:

- 实时聚合能力查询
- 当前时刻的聚合能力评估
- 调试和测试单个时间步的计算逻辑

**请求参数**:

```json
{
  "vpp_nodes": [10, 15, 18, 20, 25],
  "p_inj_max": [40000, 10000, 40000, 4000, 4000],
  "p_abs_max": [1000, 1000, 1000, 1000, 1000],
  "q_ratio": 0.5
}
```

**参数说明**:

| 字段 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| vpp_nodes | array[integer] | 是 | - | VPP 节点编号列表 |
| p_inj_max | array[number] | 是 | - | 当前时刻各节点最大注入功率，单位：kW |
| p_abs_max | array[number] | 是 | - | 当前时刻各节点最大吸收功率（正值），单位：kW |
| q_ratio | number | 否 | 0.5 | 无功功率比例，范围 [0, 1] |

**参数约束**:

- `p_inj_max` 和 `p_abs_max` 必须为 1D 数组
- 两个数组的长度必须相等且等于 `vpp_nodes` 的长度
- 所有功率值为非负数

**响应示例**:

```json
{
  "success": true,
  "data": {
    "net_inj_max": 85000.5,
    "net_abs_max": 4500.2,
    "phy_inj_sum": 90000.0,
    "phy_abs_sum": 5000.0
  },
  "metadata": {
    "vpp_nodes": [10, 15, 18, 20, 25],
    "q_ratio": 0.5
  }
}
```

**响应字段说明**:

| 字段 | 类型 | 说明 |
|------|------|------|
| success | boolean | 是否成功 |
| data.net_inj_max | number | 最大安全注入功率（kW） |
| data.net_abs_max | number | 最大安全吸收功率（kW） |
| data.phy_inj_sum | number | 物理注入功率总和（kW） |
| data.phy_abs_sum | number | 物理吸收功率总和（kW） |
| metadata.vpp_nodes | array[integer] | VPP 节点列表 |
| metadata.q_ratio | number | 使用的无功功率比例 |

**注意事项**:

- 内部实现将 1D 数组转换为单时间步的 2D 数组，然后调用相同的优化逻辑
- 会自动使用缓存中的聚合器实例（如果存在）

---

### 6. 清除聚合器缓存

**接口路径**: 

`POST /xxaqy-api/aggregator/clear_cache`

**功能说明**: 

清除内存中所有缓存的聚合器实例。用于释放内存或重置系统状态。

**使用场景**:

- 内存清理：释放不再使用的聚合器实例
- 系统重置：清除所有缓存状态
- 节点配置变更：在切换 VPP 节点配置前清除旧缓存

**请求参数**: 
无

**响应示例**:

```json
{
  "success": true,
  "message": "Cleared 3 cached aggregator(s)"
}
```

**响应字段说明**:

| 字段 | 类型 | 说明 |
|------|------|------|
| success | boolean | 是否成功 |
| message | string | 响应消息，包含清除的缓存数量 |

**注意事项**:

- 清除缓存后，下次计算需要重新初始化聚合器
- 不会影响正在进行的计算任务

---

## 错误处理

### 通用错误响应格式

所有接口在出错时都会返回以下格式的错误响应：

```json
{
  "success": false,
  "error": "错误描述",
  "traceback": "详细堆栈信息（仅在开发模式）"
}
```

### 错误码说明

| HTTP 状态码 | 说明 | 常见原因 |
|------------|------|----------|
| 400 | 请求参数错误 | 参数缺失、格式错误、约束不满足 |
| 404 | 接口不存在 | 请求路径错误 |
| 500 | 服务器内部错误 | 算法计算失败、矩阵构建失败、系统异常 |

### 常见错误示例

**参数缺失**:

```json
{
  "success": false,
  "error": "p_inj_max_profile and p_abs_max_profile are required"
}
```

**维度不匹配**:

```json
{
  "success": false,
  "error": "Number of nodes in profiles (3) does not match vpp_nodes length (5)"
}
```

**矩阵未初始化**:

```json
{
  "success": false,
  "error": "Optimization failed: network matrices not initialized"
}
```

---

## 使用流程建议

### 1. 标准使用流程

1. **健康检查** → 确认服务正常运行
2. **初始化聚合器** → 创建并缓存聚合器实例（可选，但推荐）
3. **执行聚合计算** → 调用 `solve` 或 `solve/single` 接口
4. **处理结果** → 解析返回的聚合能力数据

### 2. 批量计算优化

- 在批量计算前先调用 `init` 接口预初始化聚合器
- 设置 `use_cache=true` 复用缓存实例
- 避免频繁调用 `clear_cache`

### 3. 实时计算场景

- 直接调用 `solve/single` 接口，无需预初始化
- 系统会自动创建并使用缓存的聚合器实例

---

## 技术细节

### 算法说明

1. **约束矩阵构建** (`build_matrices`):
   - 基于 IEEE 33 节点配电系统网络拓扑
   - 计算电压和电流的灵敏度矩阵
   - 考虑基态负荷的影响

2. **聚合优化计算** (`solve_dispatch`):
   - 使用线性规划求解器（scipy.optimize.linprog）
   - 优化变量：各节点的有功功率 P 和无功功率 Q
   - 约束条件：电压约束、电流约束、物理约束

3. **功率约定**:
   - 注入功率（Injection）：DER 向电网注入功率，正值
   - 吸收功率（Absorption）：DER 从电网吸收功率，正值表示容量

### 性能考虑

- **矩阵构建**: 一次性计算，结果可复用
- **聚合器缓存**: 相同节点配置的聚合器可复用，避免重复构建
- **计算复杂度**: O(T × n)，其中 T 为时间步数，n 为优化问题的规模

---

## 更新日志

- **v1.0.0** (当前版本)
  - 初始版本发布
  - 支持 6 个核心接口
  - 基于 IEEE 33 节点系统

---

## 技术支持

如有问题或建议，请联系开发团队。

